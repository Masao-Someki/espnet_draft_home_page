import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,c as r,f as i,b as e,d as n,e as a,w as l,a as u,o as c}from"./app-KOUU_Wij.js";const m={},p=e("h1",{id:"espnet2-enh-separator-ineube-separator-ineube",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-enh-separator-ineube-separator-ineube"},[e("span",null,"espnet2.enh.separator.ineube_separator.iNeuBe")])],-1),h=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),n(" espnet2.enh.separator.ineube_separator.iNeuBe"),e("span",{class:"small-bracket"},"(n_spk=1, n_fft=512, stride=128, window='hann', mic_channels=1, hid_chans=32, hid_chans_dense=32, ksz_dense=(3, 3)"),n(", ksz_tcn=3, tcn_repeats=4, tcn_blocks=7, tcn_channels=384, activation='elu', output_from='dnn1', n_chunks=3, freeze_dnn1=False, tik_eps=1e-08)")])],-1),d=e("code",null,"AbsSeparator",-1),g=u('<p>iNeuBe, iterative neural/beamforming enhancement</p><p>Reference: Lu, Y. J., Cornell, S., Chang, X., Zhang, W., Li, C., Ni, Z., … &amp; Watanabe, S. Towards Low-Distortion Multi-Channel Speech Enhancement: The ESPNET-Se Submission to the L3DAS22 Challenge. ICASSP 2022 p. 9201-9205.</p><p>NOTES: As outlined in the Reference, this model works best when coupled with the MultiResL1SpecLoss defined in criterions/time_domain.py. The model is trained with variance normalized mixture input and target. e.g. with mixture of shape [batch, microphones, samples] you normalize it by dividing with torch.std(mixture, (1, 2)). You must do the same for the target signal. In the Reference, the variance normalization was performed offline (we normalized by the std computed on the entire training set and not for each input separately). However we found out that also normalizing each input and target separately works well.</p><ul><li><strong>Parameters:</strong><ul><li><strong>n_spk</strong> – number of output sources/speakers.</li><li><strong>n_fft</strong> – stft window size.</li><li><strong>stride</strong> – stft stride.</li><li><strong>window</strong> – stft window type choose between ‘hamming’, ‘hanning’ or None.</li><li><strong>mic_channels</strong> – number of microphones channels (only fixed-array geometry supported).</li><li><strong>hid_chans</strong> – number of channels in the subsampling/upsampling conv layers.</li><li><strong>hid_chans_dense</strong> – number of channels in the densenet layers (reduce this to reduce VRAM requirements).</li><li><strong>ksz_dense</strong> – kernel size in the densenet layers thorough iNeuBe.</li><li><strong>ksz_tcn</strong> – kernel size in the TCN submodule.</li><li><strong>tcn_repeats</strong> – number of repetitions of blocks in the TCN submodule.</li><li><strong>tcn_blocks</strong> – number of blocks in the TCN submodule.</li><li><strong>tcn_channels</strong> – number of channels in the TCN submodule.</li><li><strong>activation</strong> – activation function to use in the whole iNeuBe model, you can use any torch supported activation e.g. ‘relu’ or ‘elu’.</li><li><strong>output_from</strong> – output the estimate from ‘dnn1’, ‘mfmcwf’ or ‘dnn2’.</li><li><strong>n_chunks</strong> – number of future and past frames to consider for mfMCWF computation.</li><li><strong>freeze_dnn1</strong> – whether or not freezing dnn1 parameters during training of dnn2.</li><li><strong>tik_eps</strong> – diagonal loading in the mfMCWF computation.</li></ul></li></ul><p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p><div class="custom-h4"><p>forward<span class="small-bracket">(input: Tensor | ComplexTensor, ilens: Tensor, additional: Dict | None = None)</span></p></div><p>Forward.</p><ul><li><p><strong>Parameters:</strong></p><ul><li><strong>input</strong> (<em>torch.Tensor/ComplexTensor</em>) – batched multi-channel audio tensor with C audio channels and T samples [B, T, C]</li><li><strong>ilens</strong> (<em>torch.Tensor</em>) – input lengths [Batch]</li><li><strong>additional</strong> (<em>Dict</em> <em>or</em> <em>None</em>) – other data, currently unused in this model.</li></ul></li><li><p><strong>Returns:</strong> [(B, T), …] list of len n_spk : of mono audio tensors with T samples.</p><p>ilens (torch.Tensor): (B,) additional (Dict or None): other data, currently unused in this model,</p><blockquote><p>we return it also in output.</p></blockquote></li><li><p><strong>Return type:</strong> enhanced (List[Union[torch.Tensor, ComplexTensor]])</p></li></ul><div class="custom-h4"><p><em>static</em> mfmcwf<span class="small-bracket">(mixture, estimate, n_chunks, tik_eps)</span></p></div><p>multi-frame multi-channel wiener filter.</p><ul><li><strong>Parameters:</strong><ul><li><strong>mixture</strong> (<em>torch.Tensor</em>) – multi-channel STFT complex mixture tensor, of shape [B, T, C, F] batch, frames, microphones, frequencies.</li><li><strong>estimate</strong> (<em>torch.Tensor</em>) – monaural STFT complex estimate of target source [B, T, F] batch, frames, frequencies.</li><li><strong>n_chunks</strong> (<em>int</em>) – number of past and future mfMCWF frames. If 0 then standard MCWF.</li><li><strong>tik_eps</strong> (<em>float</em>) – diagonal loading for matrix inversion in MCWF computation.</li></ul></li><li><strong>Returns:</strong> monaural STFT complex estimate : of target source after MFMCWF [B, T, F] batch, frames, frequencies.</li><li><strong>Return type:</strong> beamformed (torch.Tensor)</li></ul><div class="custom-h4"><p><em>property</em> num_spk</p></div><div class="custom-h4"><p><em>static</em> pad2<span class="small-bracket">(input_tensor, target_len)</span></p></div><div class="custom-h4"><p>training <em>: bool</em></p></div><div class="custom-h4"><p><em>static</em> unfold<span class="small-bracket">(tf_rep, chunk_size)</span></p></div><p>unfolding STFT representation to add context in the mics channel.</p><ul><li><strong>Parameters:</strong><ul><li><strong>mixture</strong> (<em>torch.Tensor</em>) – 3D tensor (monaural complex STFT) of shape [B, T, F] batch, frames, microphones, frequencies.</li><li><strong>n_chunks</strong> (<em>int</em>) – number of past and future to consider.</li></ul></li><li><strong>Returns:</strong> complex 3D tensor STFT with context channel. : shape now is [B, T, C, F] batch, frames, context, frequencies. Basically same shape as a multi-channel STFT with C microphones.</li><li><strong>Return type:</strong> est_unfolded (torch.Tensor)</li></ul>',17);function f(_,b){const t=o("RouteLink");return c(),r("div",null,[i(" _espnet2.enh.separator.ineube_separator.iNeuBe "),p,h,e("p",null,[n("Bases: "),a(t,{to:"/guide/espnet2/enh/AbsSeparator.html#espnet2.enh.separator.abs_separator.AbsSeparator"},{default:l(()=>[d]),_:1})]),g])}const w=s(m,[["render",f],["__file","iNeuBe.html.vue"]]),N=JSON.parse(`{"path":"/guide/espnet2/enh/iNeuBe.html","title":"espnet2.enh.separator.ineube_separator.iNeuBe","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.33,"words":698},"filePathRelative":"guide/espnet2/enh/iNeuBe.md","excerpt":"<!-- _espnet2.enh.separator.ineube_separator.iNeuBe -->\\n<h1>espnet2.enh.separator.ineube_separator.iNeuBe</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.enh.separator.ineube_separator.iNeuBe<span class=\\"small-bracket\\">(n_spk=1, n_fft=512, stride=128, window='hann', mic_channels=1, hid_chans=32, hid_chans_dense=32, ksz_dense=(3, 3)</span>, ksz_tcn=3, tcn_repeats=4, tcn_blocks=7, tcn_channels=384, activation='elu', output_from='dnn1', n_chunks=3, freeze_dnn1=False, tik_eps=1e-08)</p></div>"}`);export{w as comp,N as data};
