import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as i,b as e,d as n}from"./app-KOUU_Wij.js";const s={},o=e("p",null,"<!-- _espnet.utils.spec_augment.dense_image_warp -->",-1),l=e("h1",{id:"espnet-utils-spec-augment-dense-image-warp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet-utils-spec-augment-dense-image-warp"},[e("span",null,"espnet.utils.spec_augment.dense_image_warp")])],-1),p=e("div",{class:"custom-h3"},[e("p",null,[n("espnet.utils.spec_augment.dense_image_warp"),e("span",{class:"small-bracket"},"(image, flow)")])],-1),r=e("p",null,"Image warping using per-pixel flow vectors.",-1),h=e("p",null,"Apply a non-linear warp to the image, where the warp is specified by a dense flow field of offset vectors that define the correspondences of pixel values in the output image back to locations in the source image. Specifically, the pixel value at output[b, j, i, c] is images[b, j - flow[b, j, i, 0], i - flow[b, j, i, 1], c]. The locations specified by this formula do not necessarily map to an int index. Therefore, the pixel value is obtained by bilinear interpolation of the 4 nearest pixels around (b, j - flow[b, j, i, 0], i - flow[b, j, i, 1]). For locations outside of the image, we use the nearest pixel values at the image boundary. Args: image: 4-D float Tensor with shape [batch, height, width, channels]. flow: A 4-D float Tensor with shape [batch, height, width, 2]. name: A name for the operation (optional). Note that image and flow can be of type tf.half, tf.float32, or tf.float64, and do not necessarily have to be the same type. Returns: A 4-D float Tensor with shape`[batch, height, width, channels]` and same type as input image. Raises: ValueError: if height < 2 or width < 2 or the inputs have the wrong number of dimensions.",-1),c=[o,l,p,r,h];function d(f,m){return i(),a("div",null,c)}const w=t(s,[["render",d],["__file","dense_image_warp.html.vue"]]),_=JSON.parse('{"path":"/guide/espnet/utils/dense_image_warp.html","title":"espnet.utils.spec_augment.dense_image_warp","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.81,"words":243},"filePathRelative":"guide/espnet/utils/dense_image_warp.md","excerpt":"<p>&lt;!-- _espnet.utils.spec_augment.dense_image_warp --&gt;</p>\\n<h1>espnet.utils.spec_augment.dense_image_warp</h1>\\n<div class=\\"custom-h3\\"><p>espnet.utils.spec_augment.dense_image_warp<span class=\\"small-bracket\\">(image, flow)</span></p></div>\\n<p>Image warping using per-pixel flow vectors.</p>\\n<p>Apply a non-linear warp to the image, where the warp is specified by a dense\\nflow field of offset vectors that define the correspondences of pixel values\\nin the output image back to locations in the  source image. Specifically, the\\npixel value at output[b, j, i, c] is\\nimages[b, j - flow[b, j, i, 0], i - flow[b, j, i, 1], c].\\nThe locations specified by this formula do not necessarily map to an int\\nindex. Therefore, the pixel value is obtained by bilinear\\ninterpolation of the 4 nearest pixels around\\n(b, j - flow[b, j, i, 0], i - flow[b, j, i, 1]). For locations outside\\nof the image, we use the nearest pixel values at the image boundary.\\nArgs:\\nimage: 4-D float Tensor with shape [batch, height, width, channels].\\nflow: A 4-D float Tensor with shape [batch, height, width, 2].\\nname: A name for the operation (optional).\\nNote that image and flow can be of type tf.half, tf.float32, or tf.float64,\\nand do not necessarily have to be the same type.\\nReturns:\\nA 4-D float Tensor with shape`[batch, height, width, channels]`\\nand same type as input image.\\nRaises:\\nValueError: if height &lt; 2 or width &lt; 2 or the inputs have the wrong number\\nof dimensions.</p>"}');export{w as comp,_ as data};
