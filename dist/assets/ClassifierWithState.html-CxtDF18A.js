import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as s,a,o as r}from"./app-KOUU_Wij.js";const n={},i=a('<h1 id="espnet-nets-pytorch-backend-lm-default-classifierwithstate" tabindex="-1"><a class="header-anchor" href="#espnet-nets-pytorch-backend-lm-default-classifierwithstate"><span>espnet.nets.pytorch_backend.lm.default.ClassifierWithState</span></a></h1><div class="custom-h3"><p><em>class</em> espnet.nets.pytorch_backend.lm.default.ClassifierWithState<span class="small-bracket">(predictor, lossfun=CrossEntropyLoss()</span>, label_key=-1)</p></div><p>Bases: <code>Module</code></p><p>A wrapper for pytorch RNNLM.</p><p>Initialize class.</p><p>:param torch.nn.Module predictor : The RNNLM :param function lossfun : The loss function to use :param int/str label_key :</p><div class="custom-h4"><p>buff_predict<span class="small-bracket">(state, x, n)</span></p></div><p>Predict new tokens from buffered inputs.</p><div class="custom-h4"><p>final<span class="small-bracket">(state, index=None)</span></p></div><p>Predict final log probabilities for given state using the predictor.</p><ul><li><strong>Parameters:</strong><strong>state</strong> â€“ The state</li></ul><p>:return The final log probabilities :rtype torch.Tensor</p><div class="custom-h4"><p>forward<span class="small-bracket">(state, *args, **kwargs)</span></p></div><p>Compute the loss value for an input and label pair.</p><div class="custom-h3"><p>Notes</p></div><p>It also computes accuracy and stores it to the attribute. When <code>label_key</code> is <code>int</code>, the corresponding element in <code>args</code> is treated as ground truth labels. And when it is <code>str</code>, the element in <code>kwargs</code> is used. The all elements of <code>args</code> and <code>kwargs</code> except the groundtruth labels are features. It feeds features to the predictor and compare the result with ground truth labels.</p><p>:param torch.Tensor state : the LM state :param list[torch.Tensor] args : Input minibatch :param dict[torch.Tensor] kwargs : Input minibatch :return loss value :rtype torch.Tensor</p><div class="custom-h4"><p>predict<span class="small-bracket">(state, x)</span></p></div><p>Predict log probabilities for given state and input x using the predictor.</p><p>:param torch.Tensor state : The current state :param torch.Tensor x : The input :return a tuple (new state, log prob vector) :rtype (torch.Tensor, torch.Tensor)</p><div class="custom-h4"><p>training <em>: bool</em></p></div>',21);function o(l,c){return r(),t("div",null,[s(" _espnet.nets.pytorch_backend.lm.default.ClassifierWithState "),i])}const h=e(n,[["render",o],["__file","ClassifierWithState.html.vue"]]),u=JSON.parse('{"path":"/guide/espnet/nets/ClassifierWithState.html","title":"espnet.nets.pytorch_backend.lm.default.ClassifierWithState","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.96,"words":287},"filePathRelative":"guide/espnet/nets/ClassifierWithState.md","excerpt":"<!-- _espnet.nets.pytorch_backend.lm.default.ClassifierWithState -->\\n<h1>espnet.nets.pytorch_backend.lm.default.ClassifierWithState</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.pytorch_backend.lm.default.ClassifierWithState<span class=\\"small-bracket\\">(predictor, lossfun=CrossEntropyLoss()</span>, label_key=-1)</p></div>"}');export{h as comp,u as data};
