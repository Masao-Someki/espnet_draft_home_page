import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as n,f as r,b as e,d as t,e as l,w as p,a as i,o as d}from"./app-KOUU_Wij.js";const c={},u=e("h1",{id:"espnet2-asr-state-spaces-model-sequencemodel",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-asr-state-spaces-model-sequencemodel"},[e("span",null,"espnet2.asr.state_spaces.model.SequenceModel")])],-1),m=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),t(" espnet2.asr.state_spaces.model.SequenceModel"),e("span",{class:"small-bracket"},"(d_model, n_layers=1, transposed=False, dropout=0.0, tie_dropout=False, prenorm=True, n_repeat=1, layer=None, residual=None, norm=None, pool=None, track_norms=True, dropinp=0.0, drop_path=0.0)")])],-1),h=e("code",null,"SequenceModule",-1),g=i('<p>Isotropic deep sequence model backbone, in the style of ResNets / Transformers.</p><p>The SequenceModel class implements a generic (batch, length, d_input) -&gt; (batch, length, d_output) transformation</p><ul><li><strong>Parameters:</strong><ul><li><strong>d_model</strong> – Resize input (useful for deep models with residuals)</li><li><strong>n_layers</strong> – Number of layers</li><li><strong>transposed</strong> – Transpose inputs so each layer receives (batch, dim, length)</li><li><strong>dropout</strong> – Dropout parameter applied on every residual and every layer</li><li><strong>tie_dropout</strong> – Tie dropout mask across sequence like nn.Dropout1d/nn.Dropout2d</li><li><strong>prenorm</strong> – Pre-norm vs. post-norm</li><li><strong>n_repeat</strong> – Each layer is repeated n times per stage before applying pooling</li><li><strong>layer</strong> – Layer config, must be specified</li><li><strong>residual</strong> – Residual config</li><li><strong>norm</strong> – Normalization config (e.g. layer vs batch)</li><li><strong>pool</strong> – Config for pooling layer per stage</li><li><strong>track_norms</strong> – Log norms of each layer output</li><li><strong>dropinp</strong> – Input dropout</li><li><strong>drop_path</strong> – Stochastic depth for each residual path</li></ul></li></ul><p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p><div class="custom-h4"><p><em>property</em> d_state</p></div><p>Return dimension of output of self.state_to_tensor.</p><div class="custom-h4"><p>default_state<span class="small-bracket">(*batch_shape, device=None)</span></p></div><p>Create initial state for a batch of inputs.</p><div class="custom-h4"><p>forward<span class="small-bracket">(inputs, *args, state=None, **kwargs)</span></p></div><p>Forward pass.</p><p>A sequence-to-sequence transformation with an optional state.</p><p>Generally, this should map a tensor of shape (batch, length, self.d_model) to (batch, length, self.d_output)</p><p>Additionally, it returns a “state” which can be any additional information For example, RNN and SSM layers may return their hidden state, while some types of transformer layers (e.g. Transformer-XL) may want to pass a state as well</p><div class="custom-h4"><p><em>property</em> state_to_tensor</p></div><p>Return a function mapping a state to a single tensor.</p><p>This method should be implemented if one wants to use the hidden state insteadof the output sequence for final prediction. Currently only used with the StateDecoder.</p><div class="custom-h4"><p>step<span class="small-bracket">(x, state, **kwargs)</span></p></div><p>Step the model recurrently for one step of the input sequence.</p><p>For example, this should correspond to unrolling an RNN for one step. If the forward pass has signature (B, L, H1) -&gt; (B, L, H2), this method should generally have signature (B, H1) -&gt; (B, H2) with an optional recurrent state.</p><div class="custom-h4"><p>training <em>: bool</em></p></div>',20);function _(f,y){const s=a("RouteLink");return d(),n("div",null,[r(" _espnet2.asr.state_spaces.model.SequenceModel "),u,m,e("p",null,[t("Bases: "),l(s,{to:"/guide/espnet2/asr/SequenceModule.html#espnet2.asr.state_spaces.base.SequenceModule"},{default:p(()=>[h]),_:1})]),g])}const S=o(c,[["render",_],["__file","SequenceModel.html.vue"]]),q=JSON.parse('{"path":"/guide/espnet2/asr/SequenceModel.html","title":"espnet2.asr.state_spaces.model.SequenceModel","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.44,"words":432},"filePathRelative":"guide/espnet2/asr/SequenceModel.md","excerpt":"<!-- _espnet2.asr.state_spaces.model.SequenceModel -->\\n<h1>espnet2.asr.state_spaces.model.SequenceModel</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.state_spaces.model.SequenceModel<span class=\\"small-bracket\\">(d_model, n_layers=1, transposed=False, dropout=0.0, tie_dropout=False, prenorm=True, n_repeat=1, layer=None, residual=None, norm=None, pool=None, track_norms=True, dropinp=0.0, drop_path=0.0)</span></p></div>"}');export{S as comp,q as data};
