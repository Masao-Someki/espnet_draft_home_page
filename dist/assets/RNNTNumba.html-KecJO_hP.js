import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as e,a as n,o as r}from"./app-KOUU_Wij.js";const s={},o=n('<h1 id="espnet2-asr-transducer-rnnt-multi-blank-rnnt-multi-blank-rnntnumba" tabindex="-1"><a class="header-anchor" href="#espnet2-asr-transducer-rnnt-multi-blank-rnnt-multi-blank-rnntnumba"><span>espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba</span></a></h1><div class="custom-h3"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba<span class="small-bracket">(*args, **kwargs)</span></p></div><p>Bases: <code>Function</code></p><div class="custom-h4"><p><em>static</em> backward<span class="small-bracket">(ctx, grad_output)</span></p></div><p>Defines a formula for differentiating the operation with backward mode automatic differentiation (alias to the vjp function).</p><p>This function is to be overridden by all subclasses.</p><p>It must accept a context <code>ctx</code> as the first argument, followed by as many outputs as the <a href="#espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba.forward"><code>forward()</code></a> returned (None will be passed in for non tensor outputs of the forward function), and it should return as many tensors, as there were inputs to <a href="#espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba.forward"><code>forward()</code></a>. Each argument is the gradient w.r.t the given output, and each returned value should be the gradient w.r.t. the corresponding input. If an input is not a Tensor or is a Tensor not requiring grads, you can just pass None as a gradient for that input.</p><p>The context can be used to retrieve tensors saved during the forward pass. It also has an attribute <code>ctx.needs_input_grad</code> as a tuple of booleans representing whether each input needs gradient. E.g., <a href="#espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba.backward"><code>backward()</code></a> will have <code>ctx.needs_input_grad[0] = True</code> if the first input to <a href="#espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba.forward"><code>forward()</code></a> needs gradient computated w.r.t. the output.</p><div class="custom-h4"><p><em>static</em> forward<span class="small-bracket">(ctx, acts, labels, act_lens, label_lens, blank, reduction, fastemit_lambda, clamp)</span></p></div><p>RNNTNumba Forward.</p><p>log_probs: Tensor of (batch x seqLength x labelLength x outputDim) : containing output from network</p><p>labels: 2 dimensional Tensor containing all the targets of : the batch with zero padded</p><p>act_lens: Tensor of size (batch) containing size of each : output sequence from the network</p><p>label_lens: Tensor of (batch) containing label length of each example fastemit_lambda: Float scaling factor for FastEmit regularization. Refer to</p><blockquote><p>FastEmit: Low-latency Streaming ASR with Sequence-level Emission Regularization.</p></blockquote>',15);function l(i,u){return r(),a("div",null,[e(" _espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba "),o])}const m=t(s,[["render",l],["__file","RNNTNumba.html.vue"]]),p=JSON.parse('{"path":"/guide/espnet2/asr/RNNTNumba.html","title":"espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.03,"words":310},"filePathRelative":"guide/espnet2/asr/_RNNTNumba.md","excerpt":"<!-- _espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba -->\\n<h1>espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.rnnt_multi_blank._RNNTNumba<span class=\\"small-bracket\\">(*args, **kwargs)</span></p></div>"}');export{m as comp,p as data};
