import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,c as l,f as c,b as e,d as t,e as n,w as o,a,o as m}from"./app-KOUU_Wij.js";const h={},_=a('<h1 id="espnet-nets-batch-beam-search-online-sim-batchbeamsearchonlinesim" tabindex="-1"><a class="header-anchor" href="#espnet-nets-batch-beam-search-online-sim-batchbeamsearchonlinesim"><span>espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim</span></a></h1><div class="custom-h3"><p><em>class</em> espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim<span class="small-bracket">(scorers: Dict[str, <a href="ScorerInterface.md#espnet.nets.scorer_interface.ScorerInterface">ScorerInterface</a></span>], weights: Dict[str, float], beam_size: int, vocab_size: int, sos: int, eos: int, token_list: List[str] | None = None, pre_beam_ratio: float = 1.5, pre_beam_score_key: str | None = None, return_hs: bool = False, hyp_primer: List[int] | None = None, normalize_length: bool = False)</p></div>',2),d=e("code",null,"BatchBeamSearch",-1),p=e("p",null,"Online beam search implementation.",-1),u=e("p",null,[t("This simulates streaming decoding. It requires encoded features of entire utterance and extracts block by block from it as it shoud be done in streaming processing. This is based on Tsunoo et al, “STREAMING TRANSFORMER ASR WITH BLOCKWISE SYNCHRONOUS BEAM SEARCH” ("),e("a",{href:"https://arxiv.org/abs/2006.14941",target:"_blank",rel:"noopener noreferrer"},"https://arxiv.org/abs/2006.14941"),t(").")],-1),g=e("p",null,"Initialize beam search.",-1),b=e("strong",null,"Parameters:",-1),f=e("strong",null,"scorers",-1),S=e("em",null,"dict",-1),k=e("em",null,"str",-1),B=e("em",null,",",-1),y=e("em",null,"ScorerInterface",-1),v=e("em",null,"]",-1),T=a("<li><strong>weights</strong> (<em>dict</em> *[*<em>str</em> <em>,</em> <em>float</em> <em>]</em>) – Dict of weights for each scorers The scorer will be ignored if its weight is 0</li><li><strong>beam_size</strong> (<em>int</em>) – The number of hypotheses kept during search</li><li><strong>vocab_size</strong> (<em>int</em>) – The number of vocabulary</li><li><strong>sos</strong> (<em>int</em>) – Start of sequence id</li><li><strong>eos</strong> (<em>int</em>) – End of sequence id</li><li><strong>token_list</strong> (<em>list</em> *[*<em>str</em> <em>]</em>) – List of tokens for debug log</li><li><strong>pre_beam_score_key</strong> (<em>str</em>) – key of scores to perform pre-beam search</li><li><strong>pre_beam_ratio</strong> (<em>float</em>) – beam size in the pre-beam search will be int(pre_beam_ratio * beam_size)</li><li><strong>return_hs</strong> (<em>bool</em>) – Whether to return hidden intermediates</li><li><strong>normalize_length</strong> (<em>bool</em>) – If true, select the best ended hypotheses based on length-normalized scores rather than the accumulated scores</li>",10),z=e("div",{class:"custom-h4"},[e("p",null,[t("extend"),e("span",{class:"small-bracket"},"(x: Tensor, hyps: Hypothesis)")])],-1),x=e("p",null,"Extend probabilities and states with more encoded chunks.",-1),N=e("strong",null,"Parameters:",-1),I=e("li",null,[e("strong",null,"x"),t(" ("),e("em",null,"torch.Tensor"),t(") – The extended encoder output feature")],-1),O=e("strong",null,"hyps",-1),R=e("em",null,"Hypothesis",-1),w=e("li",null,[e("strong",null,"Returns:"),t(" The extended hypothesis")],-1),H=e("strong",null,"Return type:",-1),P=e("div",{class:"custom-h4"},[e("p",null,[t("forward"),e("span",{class:"small-bracket"},"(x: Tensor, maxlenratio: float = 0.0, minlenratio: float = 0.0)")])],-1),C=e("p",null,"Perform beam search.",-1),E=a("<li><strong>Parameters:</strong><ul><li><strong>x</strong> (<em>torch.Tensor</em>) – Encoded speech feature (T, D)</li><li><strong>maxlenratio</strong> (<em>float</em>) – Input length ratio to obtain max output length. If maxlenratio=0.0 (default), it uses a end-detect function to automatically find maximum hypothesis lengths</li><li><strong>minlenratio</strong> (<em>float</em>) – Input length ratio to obtain min output length.</li></ul></li><li><strong>Returns:</strong> N-best decoding results</li>",2),L=e("strong",null,"Return type:",-1),A=a('<div class="custom-h4"><p>set_block_size<span class="small-bracket">(block_size: int)</span></p></div><p>Set block size for streaming decoding.</p><ul><li><strong>Parameters:</strong><strong>block_size</strong> (<em>int</em>) – The block size of encoder</li></ul><div class="custom-h4"><p>set_hop_size<span class="small-bracket">(hop_size: int)</span></p></div><p>Set hop size for streaming decoding.</p><ul><li><strong>Parameters:</strong><strong>hop_size</strong> (<em>int</em>) – The hop size of encoder</li></ul><div class="custom-h4"><p>set_look_ahead<span class="small-bracket">(look_ahead: int)</span></p></div><p>Set look ahead size for streaming decoding.</p><ul><li><strong>Parameters:</strong><strong>look_ahead</strong> (<em>int</em>) – The look ahead size of encoder</li></ul><div class="custom-h4"><p>set_streaming_config<span class="small-bracket">(asr_config: str)</span></p></div><p>Set config file for streaming decoding.</p><ul><li><strong>Parameters:</strong><strong>asr_config</strong> (<em>str</em>) – The config file for asr training</li></ul><div class="custom-h4"><p>training <em>: bool</em></p></div>',13);function D(F,V){const s=r("RouteLink");return m(),l("div",null,[c(" _espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim "),_,e("p",null,[t("Bases: "),n(s,{to:"/guide/espnet/nets/BatchBeamSearch.html#espnet.nets.batch_beam_search.BatchBeamSearch"},{default:o(()=>[d]),_:1})]),p,u,g,e("ul",null,[e("li",null,[b,e("ul",null,[e("li",null,[f,t(" ("),S,t(" *[*"),k,t(),B,t(),n(s,{to:"/guide/espnet/nets/ScorerInterface.html#espnet.nets.scorer_interface.ScorerInterface"},{default:o(()=>[y]),_:1}),t(),v,t(") – Dict of decoder modules e.g., Decoder, CTCPrefixScorer, LM The scorer will be ignored if it is None")]),T])])]),z,x,e("ul",null,[e("li",null,[N,e("ul",null,[I,e("li",null,[O,t(" ("),n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:o(()=>[R]),_:1}),t(") – Current list of hypothesis")])])]),w,e("li",null,[H,n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:o(()=>[t("Hypothesis")]),_:1})])]),P,C,e("ul",null,[E,e("li",null,[L,t(" list["),n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:o(()=>[t("Hypothesis")]),_:1}),t("]")])]),A])}const W=i(h,[["render",D],["__file","BatchBeamSearchOnlineSim.html.vue"]]),U=JSON.parse('{"path":"/guide/espnet/nets/BatchBeamSearchOnlineSim.html","title":"espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.69,"words":508},"filePathRelative":"guide/espnet/nets/BatchBeamSearchOnlineSim.md","excerpt":"<!-- _espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim -->\\n<h1>espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.batch_beam_search_online_sim.BatchBeamSearchOnlineSim<span class=\\"small-bracket\\">(scorers: Dict[str, <a href=\\"ScorerInterface.md#espnet.nets.scorer_interface.ScorerInterface\\">ScorerInterface</a></span>], weights: Dict[str, float], beam_size: int, vocab_size: int, sos: int, eos: int, token_list: List[str] | None = None, pre_beam_ratio: float = 1.5, pre_beam_score_key: str | None = None, return_hs: bool = False, hyp_primer: List[int] | None = None, normalize_length: bool = False)</p></div>"}');export{W as comp,U as data};
