import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as l,f as r,b as t,d as e,e as i,w as o,a as u,o as c}from"./app-KOUU_Wij.js";const m={},g=t("h1",{id:"espnet2-asr-transducer-rnnt-multi-blank-utils-cuda-utils-gpu-rnnt-multiblankgpurnnt",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#espnet2-asr-transducer-rnnt-multi-blank-utils-cuda-utils-gpu-rnnt-multiblankgpurnnt"},[t("span",null,"espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT")])],-1),p=t("div",{class:"custom-h3"},[t("p",null,[t("em",null,"class"),e(" espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT"),t("span",{class:"small-bracket"},"(sigma: float, num_big_blanks: int, minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace, big_blank_workspace, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, stream)")])],-1),d=t("code",null,"GPURNNT",-1),h=u('<p>Helper class to launch the CUDA Kernels to compute Multi-blank</p><p>Transducer Loss(<a href="https://arxiv.org/pdf/2211.03541" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/2211.03541</a>).</p><ul><li><strong>Parameters:</strong><ul><li><strong>sigma</strong> – Hyper-parameter related to the logit-normalization method in training multi-blank transducers.</li><li><strong>num_big_blanks</strong> – Number of big blank symbols the model has. This should not include the standard blank symbol.</li><li><strong>minibatch</strong> – Int representing the batch size.</li><li><strong>maxT</strong> – The maximum possible acoustic sequence length. Represents T in the logprobs tensor.</li><li><strong>maxU</strong> – The maximum possible target sequence length. Represents U in the logprobs tensor.</li><li><strong>alphabet_size</strong> – The vocabulary dimension V + 1 + num-big-blanks</li><li><strong>workspace</strong> – An allocated chunk of memory that will be sliced off and reshaped into required blocks used as working memory.</li><li><strong>big_blank_workspace</strong> – An allocated chunk of memory that will be sliced off and reshaped into required blocks used as working memory specifically for the multi-blank related computations.</li><li><strong>blank</strong> – Index of the RNNT blank token in the vocabulary. Generally the first or last token in the vocab.</li><li><strong>fastemit_lambda</strong> – Float scaling factor for FastEmit regularization. Refer to FastEmit: Low-latency Streaming ASR with Sequence-level Emission Regularization.</li><li><strong>clamp</strong> – Float value. When set to value &gt;= 0.0, will clamp the gradient to [-clamp, clamp].</li><li><strong>num_threads</strong> – Number of OMP threads to launch.</li><li><strong>stream</strong> – Numba Cuda Stream.</li></ul></li></ul><div class="custom-h4"><p>compute_cost_and_score<span class="small-bracket">(acts: Tensor, grads: Tensor | None, costs: Tensor, labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div><p>Compute both the loss and the gradients.</p><ul><li><strong>Parameters:</strong><ul><li><strong>acts</strong> – A flattened tensor of shape [B, T, U, V+1] representing the activation matrix.</li><li><strong>grad</strong> – A flattented zero tensor of same shape as acts.</li><li><strong>costs</strong> – A zero vector of length B which will be updated inplace with the log probability costs.</li><li><strong>flat_labels</strong> – A flattened matrix of labels of shape [B, U]</li><li><strong>label_lengths</strong> – A vector of length B that contains the original lengths of the acoustic sequence.</li><li><strong>input_lengths</strong> – A vector of length B that contains the original lengths of the target sequence.</li></ul></li></ul><p>Updates: : This will launch kernels that will update inline the following variables:</p><ul><li>grads: Gradients of the activation matrix wrt the costs vector.</li><li>costs: Negative log likelihood of the forward variable.</li></ul><ul><li><strong>Returns:</strong> An enum that either represents a successful RNNT operation or failure.</li></ul><div class="custom-h4"><p>cost_and_grad<span class="small-bracket">(acts: Tensor, grads: Tensor, costs: Tensor, pad_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div><div class="custom-h4"><p>score_forward<span class="small-bracket">(acts: Tensor, costs: Tensor, pad_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div>',11);function b(_,k){const n=a("RouteLink");return c(),l("div",null,[r(" _espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT "),g,p,t("p",null,[e("Bases: "),i(n,{to:"/guide/espnet2/asr/GPURNNT.html#espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT"},{default:o(()=>[d]),_:1})]),h])}const N=s(m,[["render",b],["__file","MultiblankGPURNNT.html.vue"]]),v=JSON.parse('{"path":"/guide/espnet2/asr/MultiblankGPURNNT.html","title":"espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.51,"words":454},"filePathRelative":"guide/espnet2/asr/MultiblankGPURNNT.md","excerpt":"<!-- _espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT -->\\n<h1>espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.MultiblankGPURNNT<span class=\\"small-bracket\\">(sigma: float, num_big_blanks: int, minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace, big_blank_workspace, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, stream)</span></p></div>"}');export{N as comp,v as data};
