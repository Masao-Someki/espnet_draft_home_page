import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as n,f as l,b as e,d as t,e as r,w as i,a as p,o as c}from"./app-KOUU_Wij.js";const d={},u=e("h1",{id:"espnet2-asr-state-spaces-block-sequenceresidualblock",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-asr-state-spaces-block-sequenceresidualblock"},[e("span",null,"espnet2.asr.state_spaces.block.SequenceResidualBlock")])],-1),m=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),t(" espnet2.asr.state_spaces.block.SequenceResidualBlock"),e("span",{class:"small-bracket"},"(d_input, i_layer=None, prenorm=True, dropout=0.0, tie_dropout=False, transposed=False, layer=None, residual=None, norm=None, pool=None, drop_path=0.0)")])],-1),h=e("code",null,"SequenceModule",-1),f=p('<p>Residual block wrapper for black box layer.</p><p>The SequenceResidualBlock class implements a generic (batch, length, d_input) -&gt; (batch, length, d_input) transformation</p><ul><li><strong>Parameters:</strong><ul><li><strong>d_input</strong> – Input feature dimension</li><li><strong>i_layer</strong> – Layer index, only needs to be passed into certain residuals like Decay</li><li><strong>dropout</strong> – Dropout for black box module</li><li><strong>tie_dropout</strong> – Tie dropout mask across sequence like nn.Dropout1d/nn.Dropout2d</li><li><strong>transposed</strong> – Transpose inputs so each layer receives (batch, dim, length)</li><li><strong>layer</strong> – Config for black box module</li><li><strong>residual</strong> – Config for residual function</li><li><strong>norm</strong> – Config for normalization layer</li><li><strong>pool</strong> – Config for pooling layer per stage</li><li><strong>drop_path</strong> – Drop ratio for stochastic depth</li></ul></li></ul><p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p><div class="custom-h4"><p><em>property</em> d_output</p></div><p>Output dimension of model.</p><p>This attribute is required for all SequenceModule instantiations. It is used by the rest of the pipeline (e.g. model backbone, decoder) to track the internal shapes of the full model.</p><div class="custom-h4"><p><em>property</em> d_state</p></div><p>Return dimension of output of self.state_to_tensor.</p><div class="custom-h4"><p>default_state<span class="small-bracket">(*args, **kwargs)</span></p></div><p>Create initial state for a batch of inputs.</p><div class="custom-h4"><p>forward<span class="small-bracket">(x, state=None, **kwargs)</span></p></div><p>Forward pass.</p><p>A sequence-to-sequence transformation with an optional state.</p><p>Generally, this should map a tensor of shape (batch, length, self.d_model) to (batch, length, self.d_output)</p><p>Additionally, it returns a “state” which can be any additional information For example, RNN and SSM layers may return their hidden state, while some types of transformer layers (e.g. Transformer-XL) may want to pass a state as well</p><div class="custom-h4"><p><em>property</em> state_to_tensor</p></div><p>Return a function mapping a state to a single tensor.</p><p>This method should be implemented if one wants to use the hidden state insteadof the output sequence for final prediction. Currently only used with the StateDecoder.</p><div class="custom-h4"><p>step<span class="small-bracket">(x, state, **kwargs)</span></p></div><p>Step the model recurrently for one step of the input sequence.</p><p>For example, this should correspond to unrolling an RNN for one step. If the forward pass has signature (B, L, H1) -&gt; (B, L, H2), this method should generally have signature (B, H1) -&gt; (B, H2) with an optional recurrent state.</p><div class="custom-h4"><p>training <em>: bool</em></p></div>',23);function g(_,k){const s=a("RouteLink");return c(),n("div",null,[l(" _espnet2.asr.state_spaces.block.SequenceResidualBlock "),u,m,e("p",null,[t("Bases: "),r(s,{to:"/guide/espnet2/asr/SequenceModule.html#espnet2.asr.state_spaces.base.SequenceModule"},{default:i(()=>[h]),_:1})]),f])}const q=o(d,[["render",g],["__file","SequenceResidualBlock.html.vue"]]),S=JSON.parse('{"path":"/guide/espnet2/asr/SequenceResidualBlock.html","title":"espnet2.asr.state_spaces.block.SequenceResidualBlock","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.45,"words":435},"filePathRelative":"guide/espnet2/asr/SequenceResidualBlock.md","excerpt":"<!-- _espnet2.asr.state_spaces.block.SequenceResidualBlock -->\\n<h1>espnet2.asr.state_spaces.block.SequenceResidualBlock</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.state_spaces.block.SequenceResidualBlock<span class=\\"small-bracket\\">(d_input, i_layer=None, prenorm=True, dropout=0.0, tie_dropout=False, transposed=False, layer=None, residual=None, norm=None, pool=None, drop_path=0.0)</span></p></div>"}');export{q as comp,S as data};
