import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,f as e,a as n,o as a}from"./app-KOUU_Wij.js";const l={},r=n('<h1 id="espnet2-asr-transducer-rnnt-multi-blank-utils-cpu-utils-cpu-rnnt-cpurnnt" tabindex="-1"><a class="header-anchor" href="#espnet2-asr-transducer-rnnt-multi-blank-utils-cpu-utils-cpu-rnnt-cpurnnt"><span>espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT</span></a></h1><div class="custom-h3"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT<span class="small-bracket">(minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace: Tensor, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, batch_first: bool)</span></p></div><p>Bases: <code>object</code></p><p>Helper class to compute the Transducer Loss on CPU.</p><ul><li><strong>Parameters:</strong><ul><li><strong>minibatch</strong> – Size of the minibatch b.</li><li><strong>maxT</strong> – The maximum possible acoustic sequence length. Represents T in the logprobs tensor.</li><li><strong>maxU</strong> – The maximum possible target sequence length. Represents U in the logprobs tensor.</li><li><strong>alphabet_size</strong> – The vocabulary dimension V+1 (inclusive of RNNT blank).</li><li><strong>workspace</strong> – An allocated chunk of memory that will be sliced off and reshaped into required blocks used as working memory.</li><li><strong>blank</strong> – Index of the RNNT blank token in the vocabulary. Generally the first or last token in the vocab.</li><li><strong>fastemit_lambda</strong> – Float scaling factor for FastEmit regularization. Refer to FastEmit: Low-latency Streaming ASR with Sequence-level Emission Regularization.</li><li><strong>clamp</strong> – Float value. When set to value &gt;= 0.0, will clamp the gradient to [-clamp, clamp].</li><li><strong>num_threads</strong> – Number of OMP threads to launch.</li><li><strong>batch_first</strong> – Bool that decides if batch dimension is first or third.</li></ul></li></ul><div class="custom-h4"><p>compute_alphas<span class="small-bracket">(log_probs: Tensor, T: int, U: int, alphas: Tensor)</span></p></div><p>Compute the probability of the forward variable alpha.</p><ul><li><strong>Parameters:</strong><ul><li><strong>log_probs</strong> – Flattened tensor [B, T, U, V+1]</li><li><strong>T</strong> – Length of the acoustic sequence T (not padded).</li><li><strong>U</strong> – Length of the target sequence U (not padded).</li><li><strong>alphas</strong> – Working space memory for alpha of shape [B, T, U].</li></ul></li><li><strong>Returns:</strong> Loglikelihood of the forward variable alpha.</li></ul><div class="custom-h4"><p>compute_betas_and_grads<span class="small-bracket">(grad: Tensor, log_probs: Tensor, T: int, U: int, alphas: Tensor, betas: Tensor, labels: Tensor, logll: Tensor)</span></p></div><p>Compute backward variable beta as well as gradients of the activation</p><p>matrix wrt loglikelihood of forward variable.</p><ul><li><strong>Parameters:</strong><ul><li><strong>grad</strong> – Working space memory of flattened shape [B, T, U, V+1]</li><li><strong>log_probs</strong> – Activatio tensor of flattented shape [B, T, U, V+1]</li><li><strong>T</strong> – Length of the acoustic sequence T (not padded).</li><li><strong>U</strong> – Length of the target sequence U (not padded).</li><li><strong>alphas</strong> – Working space memory for alpha of shape [B, T, U].</li><li><strong>betas</strong> – Working space memory for alpha of shape [B, T, U].</li><li><strong>labels</strong> – Ground truth label of shape [B, U]</li><li><strong>logll</strong> – Loglikelihood of the forward variable.</li></ul></li><li><strong>Returns:</strong> Loglikelihood of the forward variable and inplace updates the grad tensor.</li></ul><div class="custom-h4"><p>cost_and_grad<span class="small-bracket">(log_probs: Tensor, grads: Tensor, costs: Tensor, flat_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div><div class="custom-h4"><p>cost_and_grad_kernel<span class="small-bracket">(log_probs: Tensor, grad: Tensor, labels: Tensor, mb: int, T: int, U: int, bytes_used: int)</span></p></div><div class="custom-h4"><p>score_forward<span class="small-bracket">(log_probs: Tensor, costs: Tensor, flat_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div>',15);function o(i,c){return a(),s("div",null,[e(" _espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT "),r])}const d=t(l,[["render",o],["__file","CPURNNT.html.vue"]]),g=JSON.parse('{"path":"/guide/espnet2/asr/CPURNNT.html","title":"espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.59,"words":477},"filePathRelative":"guide/espnet2/asr/CPURNNT.md","excerpt":"<!-- _espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT -->\\n<h1>espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.utils.cpu_utils.cpu_rnnt.CPURNNT<span class=\\"small-bracket\\">(minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace: Tensor, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, batch_first: bool)</span></p></div>"}');export{d as comp,g as data};
