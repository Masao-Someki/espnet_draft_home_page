import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,f as t,a,o as n}from"./app-KOUU_Wij.js";const r={},c=a('<h1 id="espnet-nets-beam-search-timesync-streaming-beamsearchtimesyncstreaming" tabindex="-1"><a class="header-anchor" href="#espnet-nets-beam-search-timesync-streaming-beamsearchtimesyncstreaming"><span>espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming</span></a></h1><div class="custom-h3"><p><em>class</em> espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming<span class="small-bracket">(sos: int, beam_size: int, scorers: ~typing.Dict[str, ~espnet.nets.scorer_interface.ScorerInterface], weights: ~typing.Dict[str, float], token_list=&lt;class &#39;dict&#39;&gt;, pre_beam_ratio: float = 1.5, blank: int = 0, hold_n: int = 0)</span></p></div><p>Bases: <code>Module</code></p><p>Time synchronous beam search algorithm.</p><p>Initialize beam search.</p><ul><li><strong>Parameters:</strong><ul><li><strong>beam_size</strong> – num hyps</li><li><strong>sos</strong> – sos index</li><li><strong>ctc</strong> – CTC module</li><li><strong>pre_beam_ratio</strong> – pre_beam_ratio * beam_size = pre_beam pre_beam is used to select candidates from vocab to extend hypotheses</li><li><strong>decoder</strong> – decoder ScorerInterface</li><li><strong>ctc_weight</strong> – ctc_weight</li><li><strong>blank</strong> – blank index</li></ul></li></ul><div class="custom-h4"><p>cached_score<span class="small-bracket">(h: Tuple[int], cache: dict, scorer: <a href="ScorerInterface.md#espnet.nets.scorer_interface.ScorerInterface">ScorerInterface</a></span>, recompute_cache: bool = False)</p></div><p>Retrieve decoder/LM scores which may be cached.</p><div class="custom-h4"><p>forward<span class="small-bracket">(x: Tensor, maxlenratio: float = 0.0, minlenratio: float = 0.0, start_idx: int = 0, is_final: bool = False, incremental_decode: bool = False)</span></p></div><p>Perform beam search.</p><ul><li><strong>Parameters:</strong><strong>enc_output</strong> (<em>torch.Tensor</em>) –</li><li><strong>Returns:</strong> list[Hypothesis]</li></ul><div class="custom-h4"><p>joint_score<span class="small-bracket">(hyps: Any, ctc_score_dp: Any, recompute_cache: bool = False)</span></p></div><p>Calculate joint score for hyps.</p><div class="custom-h4"><p>reset<span class="small-bracket">(enc_output: Tensor)</span></p></div><p>Reset object for a new utterance.</p><div class="custom-h4"><p>time_step<span class="small-bracket">(p_ctc: Any, ctc_score_dp: Any, hyps: Any, recompute_cache: bool = False)</span></p></div><p>Execute a single time step.</p><div class="custom-h4"><p>training <em>: bool</em></p></div>',18);function i(m,o){return n(),s("div",null,[t(" _espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming "),c])}const _=e(r,[["render",i],["__file","BeamSearchTimeSyncStreaming.html.vue"]]),h=JSON.parse(`{"path":"/guide/espnet/nets/BeamSearchTimeSyncStreaming.html","title":"espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.82,"words":245},"filePathRelative":"guide/espnet/nets/BeamSearchTimeSyncStreaming.md","excerpt":"<!-- _espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming -->\\n<h1>espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.beam_search_timesync_streaming.BeamSearchTimeSyncStreaming<span class=\\"small-bracket\\">(sos: int, beam_size: int, scorers: ~typing.Dict[str, ~espnet.nets.scorer_interface.ScorerInterface], weights: ~typing.Dict[str, float], token_list=&lt;class 'dict'&gt;, pre_beam_ratio: float = 1.5, blank: int = 0, hold_n: int = 0)</span></p></div>"}`);export{_ as comp,h as data};
