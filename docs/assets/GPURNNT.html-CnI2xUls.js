import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as s,a as n,o as a}from"./app-KOUU_Wij.js";const l={},r=n('<h1 id="espnet2-asr-transducer-rnnt-multi-blank-utils-cuda-utils-gpu-rnnt-gpurnnt" tabindex="-1"><a class="header-anchor" href="#espnet2-asr-transducer-rnnt-multi-blank-utils-cuda-utils-gpu-rnnt-gpurnnt"><span>espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT</span></a></h1><div class="custom-h3"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT<span class="small-bracket">(minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, stream)</span></p></div><p>Bases: <code>object</code></p><p>Helper class to launch the CUDA Kernels to compute the Transducer Loss.</p><ul><li><strong>Parameters:</strong><ul><li><strong>minibatch</strong> – Int representing the batch size.</li><li><strong>maxT</strong> – The maximum possible acoustic sequence length. Represents T in the logprobs tensor.</li><li><strong>maxU</strong> – The maximum possible target sequence length. Represents U in the logprobs tensor.</li><li><strong>alphabet_size</strong> – The vocabulary dimension V+1 (inclusive of RNNT blank).</li><li><strong>workspace</strong> – An allocated chunk of memory that will be sliced off and reshaped into required blocks used as working memory.</li><li><strong>blank</strong> – Index of the RNNT blank token in the vocabulary. Generally the first or last token in the vocab.</li><li><strong>fastemit_lambda</strong> – Float scaling factor for FastEmit regularization. Refer to FastEmit: Low-latency Streaming ASR with Sequence-level Emission Regularization.</li><li><strong>clamp</strong> – Float value. When set to value &gt;= 0.0, will clamp the gradient to [-clamp, clamp].</li><li><strong>num_threads</strong> – Number of OMP threads to launch.</li><li><strong>stream</strong> – Numba Cuda Stream.</li></ul></li></ul><div class="custom-h4"><p>compute_cost_and_score<span class="small-bracket">(acts: Tensor, grads: Tensor | None, costs: Tensor, labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div><p>Compute both the loss and the gradients.</p><ul><li><strong>Parameters:</strong><ul><li><strong>acts</strong> – A flattened tensor of shape [B, T, U, V+1] representing the activation matrix.</li><li><strong>grad</strong> – A flattented zero tensor of same shape as acts.</li><li><strong>costs</strong> – A zero vector of length B which will be updated inplace with the log probability costs.</li><li><strong>flat_labels</strong> – A flattened matrix of labels of shape [B, U]</li><li><strong>label_lengths</strong> – A vector of length B that contains the original lengths of the acoustic sequence.</li><li><strong>input_lengths</strong> – A vector of length B that contains the original lengths of the target sequence.</li></ul></li></ul><p>Updates: : This will launch kernels that will update inline the following variables:</p><ul><li>grads: Gradients of the activation matrix wrt the costs vector.</li><li>costs: Negative log likelihood of the forward variable.</li></ul><ul><li><strong>Returns:</strong> An enum that either represents a successful RNNT operation or failure.</li></ul><div class="custom-h4"><p>cost_and_grad<span class="small-bracket">(acts: Tensor, grads: Tensor, costs: Tensor, pad_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div><div class="custom-h4"><p>log_softmax<span class="small-bracket">(acts: Tensor, denom: Tensor)</span></p></div><p>Computes the log softmax denominator of the input activation tensor</p><p>and stores the result in denom.</p><ul><li><strong>Parameters:</strong><ul><li><strong>acts</strong> – Activation tensor of shape [B, T, U, V+1]. The input must be represented as a flat tensor of shape [B * T * U * (V+1)] to allow pointer indexing.</li><li><strong>denom</strong> – A zero tensor of same shape as acts.</li></ul></li></ul><p>Updates: : This kernel inplace updates the denom tensor</p><div class="custom-h4"><p>score_forward<span class="small-bracket">(acts: Tensor, costs: Tensor, pad_labels: Tensor, label_lengths: Tensor, input_lengths: Tensor)</span></p></div>',18);function o(i,c){return a(),e("div",null,[s(" _espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT "),r])}const m=t(l,[["render",o],["__file","GPURNNT.html.vue"]]),g=JSON.parse('{"path":"/guide/espnet2/asr/GPURNNT.html","title":"espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.56,"words":467},"filePathRelative":"guide/espnet2/asr/GPURNNT.md","excerpt":"<!-- _espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT -->\\n<h1>espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.asr.transducer.rnnt_multi_blank.utils.cuda_utils.gpu_rnnt.GPURNNT<span class=\\"small-bracket\\">(minibatch: int, maxT: int, maxU: int, alphabet_size: int, workspace, blank: int, fastemit_lambda: float, clamp: float, num_threads: int, stream)</span></p></div>"}');export{m as comp,g as data};
