import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,f as s,a,o as t}from"./app-KOUU_Wij.js";const o={},p=a('<h1 id="espnet2-enh-layers-ncsnpp-utils-up-or-down-sampling-upsample-conv-2d" tabindex="-1"><a class="header-anchor" href="#espnet2-enh-layers-ncsnpp-utils-up-or-down-sampling-upsample-conv-2d"><span>espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d</span></a></h1><div class="custom-h3"><p>espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d<span class="small-bracket">(x, w, k=None, factor=2, gain=1)</span></p></div><p>Fused upsample_2d() followed by tf.nn.conv2d().</p><p>Padding is performed only once at the beginning, not between the operations. The fused op is considerably more efficient than performing the same calculation using standard TensorFlow ops. It supports gradients of arbitrary order. :param x: Input tensor of the shape [N, C, H, W] or</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[N, H, W,</p><blockquote><p>C]`.</p></blockquote><ul><li><strong>Parameters:</strong><ul><li><strong>w</strong> – Weight tensor of the shape [filterH, filterW, inChannels, outChannels]. Grouped convolution can be performed by inChannels = x.shape[0] // numGroups.</li><li><strong>k</strong> – FIR filter of the shape [firH, firW] or [firN] (separable). The default is [1] * factor, which corresponds to nearest-neighbor upsampling.</li><li><strong>factor</strong> – Integer upsampling factor (default: 2).</li><li><strong>gain</strong> – Scaling factor for signal magnitude (default: 1.0).</li></ul></li><li><strong>Returns:</strong> Tensor of the shape [N, C, H * factor, W * factor] or [N, H * factor, W * factor, C], and same datatype as x.</li></ul>',8);function r(i,l){return t(),n("div",null,[s(" _espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d "),p])}const u=e(o,[["render",r],["__file","upsample_conv_2d.html.vue"]]),_=JSON.parse('{"path":"/guide/espnet2/enh/upsample_conv_2d.html","title":"espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.55,"words":165},"filePathRelative":"guide/espnet2/enh/upsample_conv_2d.md","excerpt":"<!-- _espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d -->\\n<h1>espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d</h1>\\n<div class=\\"custom-h3\\"><p>espnet2.enh.layers.ncsnpp_utils.up_or_down_sampling.upsample_conv_2d<span class=\\"small-bracket\\">(x, w, k=None, factor=2, gain=1)</span></p></div>"}');export{u as comp,_ as data};
