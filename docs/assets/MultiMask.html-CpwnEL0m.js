import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as l,b as e,d as s,e as i,w as o,a as r,o as m}from"./app-KOUU_Wij.js";const u={},c=e("p",null,"<!-- _espnet2.diar.layers.multi_mask.MultiMask -->",-1),p=e("h1",{id:"espnet2-diar-layers-multi-mask-multimask",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-diar-layers-multi-mask-multimask"},[e("span",null,"espnet2.diar.layers.multi_mask.MultiMask")])],-1),d=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),s(" espnet2.diar.layers.multi_mask.MultiMask"),e("span",{class:"small-bracket"},"(input_dim: int, bottleneck_dim: int = 128, max_num_spk: int = 3, mask_nonlinear='relu')")])],-1),k=e("code",null,"AbsMask",-1),_=r('<p>Multiple 1x1 convolution layer Module.</p><p>This module corresponds to the final 1x1 conv block and non-linear function in TCNSeparator. This module has multiple 1x1 conv blocks. One of them is selected according to the given num_spk to handle flexible num_spk.</p><ul><li><strong>Parameters:</strong><ul><li><strong>input_dim</strong> – Number of filters in autoencoder</li><li><strong>bottleneck_dim</strong> – Number of channels in bottleneck 1 * 1-conv block</li><li><strong>max_num_spk</strong> – Number of mask_conv1x1 modules (&gt;= Max number of speakers in the dataset)</li><li><strong>mask_nonlinear</strong> – use which non-linear function to generate mask</li></ul></li></ul><div class="custom-h4"><p>forward<span class="small-bracket">(input: Tensor | ComplexTensor, ilens: Tensor, bottleneck_feat: Tensor, num_spk: int)</span></p></div><p>Keep this API same with TasNet.</p><ul><li><p><strong>Parameters:</strong></p><ul><li><strong>input</strong> – [M, K, N], M is batch size</li><li><strong>ilens</strong> (<em>torch.Tensor</em>) – (M,)</li><li><strong>bottleneck_feat</strong> – [M, K, B]</li><li><strong>num_spk</strong> – number of speakers</li><li>**(**<strong>Training</strong> – oracle,</li><li><strong>Inference</strong> – estimated by other module (e.g, EEND-EDA))</li></ul></li><li><p><strong>Returns:</strong> [(M, K, N), …] ilens (torch.Tensor): (M,) others predicted data, e.g. masks: OrderedDict[</p><blockquote><p>’mask_spk1’: torch.Tensor(Batch, Frames, Freq), ‘mask_spk2’: torch.Tensor(Batch, Frames, Freq), … ‘mask_spkn’: torch.Tensor(Batch, Frames, Freq),</p></blockquote><p>]</p></li><li><p><strong>Return type:</strong> masked (List[Union(torch.Tensor, ComplexTensor)])</p></li></ul><div class="custom-h4"><p><em>property</em> max_num_spk <em>: int</em></p></div><div class="custom-h4"><p>training <em>: bool</em></p></div>',8);function h(g,M){const t=a("RouteLink");return m(),l("div",null,[c,p,d,e("p",null,[s("Bases: "),i(t,{to:"/guide/espnet2/diar/AbsMask.html#espnet2.diar.layers.abs_mask.AbsMask"},{default:o(()=>[k]),_:1})]),_])}const T=n(u,[["render",h],["__file","MultiMask.html.vue"]]),v=JSON.parse(`{"path":"/guide/espnet2/diar/MultiMask.html","title":"espnet2.diar.layers.multi_mask.MultiMask","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.77,"words":231},"filePathRelative":"guide/espnet2/diar/MultiMask.md","excerpt":"<p>&lt;!-- _espnet2.diar.layers.multi_mask.MultiMask --&gt;</p>\\n<h1>espnet2.diar.layers.multi_mask.MultiMask</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.diar.layers.multi_mask.MultiMask<span class=\\"small-bracket\\">(input_dim: int, bottleneck_dim: int = 128, max_num_spk: int = 3, mask_nonlinear='relu')</span></p></div>"}`);export{T as comp,v as data};
