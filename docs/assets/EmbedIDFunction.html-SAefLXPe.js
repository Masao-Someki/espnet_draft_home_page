import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as n,a as i,o as s}from"./app-KOUU_Wij.js";const a={},o=i('<h1 id="espnet-nets-chainer-backend-deterministic-embed-id-embedidfunction" tabindex="-1"><a class="header-anchor" href="#espnet-nets-chainer-backend-deterministic-embed-id-embedidfunction"><span>espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction</span></a></h1><div class="custom-h3"><p><em>class</em> espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction<span class="small-bracket">(ignore_label=None)</span></p></div><p>Bases: <code>FunctionNode</code></p><div class="custom-h4"><p>backward<span class="small-bracket">(indexes, grad_outputs)</span></p></div><p>Computes gradients w.r.t. specified inputs given output gradients.</p><p>This method is used to compute one step of the backpropagation corresponding to the forward computation of this function node. Given the gradients w.r.t. output variables, this method computes the gradients w.r.t. specified input variables. Note that this method does not need to compute any input gradients not specified by <code>target_input_indices</code>.</p><p>Unlike <code>Function.backward()</code>, gradients are given as <code>Variable</code> objects and this method itself has to return input gradients as <code>Variable</code> objects. It enables the function node to return the input gradients with the full computational history, in which case it supports <em>differentiable backpropagation</em> or <em>higher-order differentiation</em>.</p><p>The default implementation returns <code>None</code> s, which means the function is not differentiable.</p><ul><li><strong>Parameters:</strong><ul><li><strong>target_input_indexes</strong> (<em>tuple</em> <em>of</em> <em>int</em>) – Sorted indices of the input variables w.r.t. which the gradients are required. It is guaranteed that this tuple contains at least one element.</li><li><strong>grad_outputs</strong> (tuple of <code>Variable</code>s) – Gradients w.r.t. the output variables. If the gradient w.r.t. an output variable is not given, the corresponding element is <code>None</code>.</li></ul></li><li><strong>Returns:</strong> Tuple of variables that represent the gradients w.r.t. specified input variables. The length of the tuple can be same as either <code>len(target_input_indexes)</code> or the number of inputs. In the latter case, the elements not specified by <code>target_input_indexes</code> will be discarded.</li></ul><div class="custom-h4"><p>SEE ALSO</p></div><p><code>backward_accumulate()</code> provides an alternative interface that allows you to implement the backward computation fused with the gradient accumulation.</p><div class="custom-h4"><p>check_type_forward<span class="small-bracket">(in_types)</span></p></div><p>Checks types of input data before forward propagation.</p><p>This method is called before <a href="#espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction.forward"><code>forward()</code></a> and validates the types of input variables using the type checking utilities.</p><ul><li><strong>Parameters:</strong><strong>in_types</strong> (<em>TypeInfoTuple</em>) – The type information of input variables for <a href="#espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction.forward"><code>forward()</code></a>.</li></ul><div class="custom-h4"><p>forward<span class="small-bracket">(inputs)</span></p></div><p>Computes the output arrays from the input arrays.</p><p>It delegates the procedure to <code>forward_cpu()</code> or <code>forward_gpu()</code> by default. Which of them this method selects is determined by the type of input arrays. Implementations of <code>FunctionNode</code> must implement either CPU/GPU methods or this method.</p><ul><li><strong>Parameters:</strong><strong>inputs</strong> – Tuple of input array(s).</li><li><strong>Returns:</strong> Tuple of output array(s).</li></ul><div class="custom-h4"><p>WARNING</p></div><p>Implementations of <code>FunctionNode</code> must take care that the return value must be a tuple even if it returns only one array.</p>',21);function r(d,c){return s(),t("div",null,[n(" _espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction "),o])}const m=e(a,[["render",r],["__file","EmbedIDFunction.html.vue"]]),l=JSON.parse('{"path":"/guide/espnet/nets/EmbedIDFunction.html","title":"espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.45,"words":435},"filePathRelative":"guide/espnet/nets/EmbedIDFunction.md","excerpt":"<!-- _espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction -->\\n<h1>espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.chainer_backend.deterministic_embed_id.EmbedIDFunction<span class=\\"small-bracket\\">(ignore_label=None)</span></p></div>"}');export{m as comp,l as data};
