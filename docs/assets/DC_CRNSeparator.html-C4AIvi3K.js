import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,c as o,f as a,b as e,d as n,e as l,w as i,a as p,o as c}from"./app-KOUU_Wij.js";const m={},d=e("h1",{id:"espnet2-enh-separator-dc-crn-separator-dc-crnseparator",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-enh-separator-dc-crn-separator-dc-crnseparator"},[e("span",null,"espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator")])],-1),_=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),n(" espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator"),e("span",{class:"small-bracket"},"(input_dim: int, num_spk: int = 2, predict_noise: bool = False, input_channels: List = [2, 16, 32, 64, 128, 256], enc_hid_channels: int = 8, enc_kernel_size: Tuple = (1, 3)"),n(", enc_padding: Tuple = (0, 1), enc_last_kernel_size: Tuple = (1, 4), enc_last_stride: Tuple = (1, 2), enc_last_padding: Tuple = (0, 1), enc_layers: int = 5, skip_last_kernel_size: Tuple = (1, 3), skip_last_stride: Tuple = (1, 1), skip_last_padding: Tuple = (0, 1), glstm_groups: int = 2, glstm_layers: int = 2, glstm_bidirectional: bool = False, glstm_rearrange: bool = False, mode: str = 'masking', ref_channel: int = 0)")])],-1),h=e("code",null,"AbsSeparator",-1),g=p('<p>Densely-Connected Convolutional Recurrent Network (DC-CRN) Separator</p><p>Reference: : Deep Learning Based Real-Time Speech Enhancement for Dual-Microphone Mobile Phones; Tan et al., 2020 <a href="https://web.cse.ohio-state.edu/~wang.77/papers/TZW.taslp21.pdf" target="_blank" rel="noopener noreferrer">https://web.cse.ohio-state.edu/~wang.77/papers/TZW.taslp21.pdf</a></p><ul><li><strong>Parameters:</strong><ul><li><strong>input_dim</strong> – input feature dimension</li><li><strong>num_spk</strong> – number of speakers</li><li><strong>predict_noise</strong> – whether to output the estimated noise signal</li><li><strong>input_channels</strong> (<em>list</em>) – number of input channels for the stacked DenselyConnectedBlock layers Its length should be (number of DenselyConnectedBlock layers).</li><li><strong>enc_hid_channels</strong> (<em>int</em>) – common number of intermediate channels for all DenselyConnectedBlock of the encoder</li><li><strong>enc_kernel_size</strong> (<em>tuple</em>) – common kernel size for all DenselyConnectedBlock of the encoder</li><li><strong>enc_padding</strong> (<em>tuple</em>) – common padding for all DenselyConnectedBlock of the encoder</li><li><strong>enc_last_kernel_size</strong> (<em>tuple</em>) – common kernel size for the last Conv layer in all DenselyConnectedBlock of the encoder</li><li><strong>enc_last_stride</strong> (<em>tuple</em>) – common stride for the last Conv layer in all DenselyConnectedBlock of the encoder</li><li><strong>enc_last_padding</strong> (<em>tuple</em>) – common padding for the last Conv layer in all DenselyConnectedBlock of the encoder</li><li><strong>enc_layers</strong> (<em>int</em>) – common total number of Conv layers for all DenselyConnectedBlock layers of the encoder</li><li><strong>skip_last_kernel_size</strong> (<em>tuple</em>) – common kernel size for the last Conv layer in all DenselyConnectedBlock of the skip pathways</li><li><strong>skip_last_stride</strong> (<em>tuple</em>) – common stride for the last Conv layer in all DenselyConnectedBlock of the skip pathways</li><li><strong>skip_last_padding</strong> (<em>tuple</em>) – common padding for the last Conv layer in all DenselyConnectedBlock of the skip pathways</li><li><strong>glstm_groups</strong> (<em>int</em>) – number of groups in each Grouped LSTM layer</li><li><strong>glstm_layers</strong> (<em>int</em>) – number of Grouped LSTM layers</li><li><strong>glstm_bidirectional</strong> (<em>bool</em>) – whether to use BLSTM or unidirectional LSTM in Grouped LSTM layers</li><li><strong>glstm_rearrange</strong> (<em>bool</em>) – whether to apply the rearrange operation after each grouped LSTM layer</li><li><strong>output_channels</strong> (<em>int</em>) – number of output channels (even number)</li><li><strong>mode</strong> (<em>str</em>) – one of (“mapping”, “masking”) “mapping”: complex spectral mapping “masking”: complex masking</li><li><strong>ref_channel</strong> (<em>int</em>) – index of the reference microphone</li></ul></li></ul><div class="custom-h4"><p>forward<span class="small-bracket">(input: Tensor | ComplexTensor, ilens: Tensor, additional: Dict | None = None)</span></p></div><p>DC-CRN Separator Forward.</p><ul><li><p><strong>Parameters:</strong></p><ul><li><strong>input</strong> (<em>torch.Tensor</em> <em>or</em> <em>ComplexTensor</em>) – Encoded feature [Batch, T, F] or [Batch, T, C, F]</li><li><strong>ilens</strong> (<em>torch.Tensor</em>) – input lengths [Batch,]</li></ul></li><li><p><strong>Returns:</strong> [(Batch, T, F), …] ilens (torch.Tensor): (B,) others predicted data, e.g. masks: OrderedDict[</p><blockquote><p>’mask_spk1’: torch.Tensor(Batch, Frames, Freq), ‘mask_spk2’: torch.Tensor(Batch, Frames, Freq), … ‘mask_spkn’: torch.Tensor(Batch, Frames, Freq),</p></blockquote><p>]</p></li><li><p><strong>Return type:</strong> masked (List[Union(torch.Tensor, ComplexTensor)])</p></li></ul><div class="custom-h4"><p><em>property</em> num_spk</p></div><div class="custom-h4"><p>training <em>: bool</em></p></div>',8);function u(k,f){const t=r("RouteLink");return c(),o("div",null,[a(" _espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator "),d,_,e("p",null,[n("Bases: "),l(t,{to:"/guide/espnet2/enh/AbsSeparator.html#espnet2.enh.separator.abs_separator.AbsSeparator"},{default:i(()=>[h]),_:1})]),g])}const y=s(m,[["render",u],["__file","DC_CRNSeparator.html.vue"]]),b=JSON.parse(`{"path":"/guide/espnet2/enh/DC_CRNSeparator.html","title":"espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.61,"words":482},"filePathRelative":"guide/espnet2/enh/DC_CRNSeparator.md","excerpt":"<!-- _espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator -->\\n<h1>espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.enh.separator.dc_crn_separator.DC_CRNSeparator<span class=\\"small-bracket\\">(input_dim: int, num_spk: int = 2, predict_noise: bool = False, input_channels: List = [2, 16, 32, 64, 128, 256], enc_hid_channels: int = 8, enc_kernel_size: Tuple = (1, 3)</span>, enc_padding: Tuple = (0, 1), enc_last_kernel_size: Tuple = (1, 4), enc_last_stride: Tuple = (1, 2), enc_last_padding: Tuple = (0, 1), enc_layers: int = 5, skip_last_kernel_size: Tuple = (1, 3), skip_last_stride: Tuple = (1, 1), skip_last_padding: Tuple = (0, 1), glstm_groups: int = 2, glstm_layers: int = 2, glstm_bidirectional: bool = False, glstm_rearrange: bool = False, mode: str = 'masking', ref_channel: int = 0)</p></div>"}`);export{y as comp,b as data};
