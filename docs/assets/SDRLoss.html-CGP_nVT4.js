import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,c as i,f as a,b as e,d as s,e as l,w as r,a as c,o as d}from"./app-KOUU_Wij.js";const m={},p=e("h1",{id:"espnet2-enh-loss-criterions-time-domain-sdrloss",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet2-enh-loss-criterions-time-domain-sdrloss"},[e("span",null,"espnet2.enh.loss.criterions.time_domain.SDRLoss")])],-1),h=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),s(" espnet2.enh.loss.criterions.time_domain.SDRLoss"),e("span",{class:"small-bracket"},"(filter_length=512, use_cg_iter=None, clamp_db=None, zero_mean=True, load_diag=None, name=None, only_for_test=False, is_noise_loss=False, is_dereverb_loss=False)")])],-1),_=e("code",null,"TimeDomainLoss",-1),u=c('<p>SDR loss.</p><p>filter_length: int : The length of the distortion filter allowed (default: <code>512</code>)</p><p>use_cg_iter: : If provided, an iterative method is used to solve for the distortion filter coefficients instead of direct Gaussian elimination. This can speed up the computation of the metrics in case the filters are long. Using a value of 10 here has been shown to provide good accuracy in most cases and is sufficient when using this loss to train neural separation networks.</p><p>clamp_db: float : clamp the output value in [-clamp_db, clamp_db]</p><p>zero_mean: bool : When set to True, the mean of all signals is subtracted prior.</p><p>load_diag: : If provided, this small value is added to the diagonal coefficients of the system metrices when solving for the filter coefficients. This can help stabilize the metric in the case where some of the reference signals may sometimes be zero</p><p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p><div class="custom-h4"><p>forward<span class="small-bracket">(ref: Tensor, est: Tensor)</span></p></div><p>SDR forward.</p><ul><li><strong>Parameters:</strong><ul><li><strong>ref</strong> – Tensor, (…, n_samples) reference signal</li><li><strong>est</strong> – Tensor (…, n_samples) estimated signal</li></ul></li><li><strong>Returns:</strong> (…,) : the SDR loss (negative sdr)</li><li><strong>Return type:</strong> loss</li></ul><div class="custom-h4"><p>training <em>: bool</em></p></div>',11);function f(g,v){const t=n("RouteLink");return d(),i("div",null,[a(" _espnet2.enh.loss.criterions.time_domain.SDRLoss "),p,h,e("p",null,[s("Bases: "),l(t,{to:"/guide/espnet2/enh/TimeDomainLoss.html#espnet2.enh.loss.criterions.time_domain.TimeDomainLoss"},{default:r(()=>[_]),_:1})]),u])}const S=o(m,[["render",f],["__file","SDRLoss.html.vue"]]),D=JSON.parse('{"path":"/guide/espnet2/enh/SDRLoss.html","title":"espnet2.enh.loss.criterions.time_domain.SDRLoss","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.8,"words":240},"filePathRelative":"guide/espnet2/enh/SDRLoss.md","excerpt":"<!-- _espnet2.enh.loss.criterions.time_domain.SDRLoss -->\\n<h1>espnet2.enh.loss.criterions.time_domain.SDRLoss</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.enh.loss.criterions.time_domain.SDRLoss<span class=\\"small-bracket\\">(filter_length=512, use_cg_iter=None, clamp_db=None, zero_mean=True, load_diag=None, name=None, only_for_test=False, is_noise_loss=False, is_dereverb_loss=False)</span></p></div>"}');export{S as comp,D as data};
