import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,c as r,f as i,b as e,d as t,e as a,w as c,a as l,o as d}from"./app-KOUU_Wij.js";const p={},u=e("h1",{id:"espnet-nets-pytorch-backend-transducer-custom-decoder-customdecoder",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet-nets-pytorch-backend-transducer-custom-decoder-customdecoder"},[e("span",null,"espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder")])],-1),_=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),t(" espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder"),e("span",{class:"small-bracket"},"(odim: int, dec_arch: List, input_layer: str = 'embed', repeat_block: int = 0, joint_activation_type: str = 'tanh', positional_encoding_type: str = 'abs_pos', positionwise_layer_type: str = 'linear', positionwise_activation_type: str = 'relu', input_layer_dropout_rate: float = 0.0, blank_id: int = 0)")])],-1),g=e("code",null,"TransducerDecoderInterface",-1),m=e("code",null,"Module",-1),h=l('<p>Custom decoder module for Transducer model.</p><ul><li><strong>Parameters:</strong><ul><li><strong>odim</strong> – Output dimension.</li><li><strong>dec_arch</strong> – Decoder block architecture (type and parameters).</li><li><strong>input_layer</strong> – Input layer type.</li><li><strong>repeat_block</strong> – Number of times dec_arch is repeated.</li><li><strong>joint_activation_type</strong> – Type of activation for joint network.</li><li><strong>positional_encoding_type</strong> – Positional encoding type.</li><li><strong>positionwise_layer_type</strong> – Positionwise layer type.</li><li><strong>positionwise_activation_type</strong> – Positionwise activation type.</li><li><strong>input_layer_dropout_rate</strong> – Dropout rate for input layer.</li><li><strong>blank_id</strong> – Blank symbol ID.</li></ul></li></ul><p>Construct a CustomDecoder object.</p><div class="custom-h4"><p>batch_score<span class="small-bracket">(hyps: List[Hypothesis] | List[<a href="ExtendedHypothesis.md#espnet.nets.transducer_decoder_interface.ExtendedHypothesis">ExtendedHypothesis</a></span>], dec_states: List[Tensor | None], cache: Dict[str, Any], use_lm: bool)</p></div><p>One-step forward hypotheses.</p><ul><li><strong>Parameters:</strong><ul><li><strong>hyps</strong> – Hypotheses.</li><li><strong>dec_states</strong> – Decoder hidden states. [N x (B, U, D_dec)]</li><li><strong>cache</strong> – Pairs of (h_dec, dec_states) for each label sequences. (keys)</li><li><strong>use_lm</strong> – Whether to compute label ID sequences for LM.</li></ul></li><li><strong>Returns:</strong> Decoder output sequences. (B, D_dec) dec_states: Decoder hidden states. [N x (B, U, D_dec)] lm_labels: Label ID sequences for LM. (B,)</li><li><strong>Return type:</strong> dec_out</li></ul><div class="custom-h4"><p>create_batch_states<span class="small-bracket">(states: List[Tensor | None], new_states: List[Tensor | None], check_list: List[List[int]])</span></p></div><p>Create decoder hidden states sequences.</p><ul><li><strong>Parameters:</strong><ul><li><strong>states</strong> – Decoder hidden states. [N x (B, U, D_dec)]</li><li><strong>new_states</strong> – Decoder hidden states. [B x [N x (1, U, D_dec)]]</li><li><strong>check_list</strong> – Label ID sequences.</li></ul></li><li><strong>Returns:</strong> New decoder hidden states. [N x (B, U, D_dec)]</li><li><strong>Return type:</strong> states</li></ul><div class="custom-h4"><p>forward<span class="small-bracket">(dec_input: Tensor, dec_mask: Tensor)</span></p></div><p>Encode label ID sequences.</p><ul><li><strong>Parameters:</strong><ul><li><strong>dec_input</strong> – Label ID sequences. (B, U)</li><li><strong>dec_mask</strong> – Label mask sequences. (B, U)</li></ul></li><li><strong>Returns:</strong> Decoder output sequences. (B, U, D_dec) dec_output_mask: Mask of decoder output sequences. (B, U)</li><li><strong>Return type:</strong> dec_output</li></ul><div class="custom-h4"><p>init_state<span class="small-bracket">(batch_size: int | None = None)</span></p></div><p>Initialize decoder states.</p><ul><li><strong>Parameters:</strong><strong>batch_size</strong> – Batch size.</li><li><strong>Returns:</strong> Initial decoder hidden states. [N x None]</li><li><strong>Return type:</strong> state</li></ul><div class="custom-h4"><p>score<span class="small-bracket">(hyp: Hypothesis, cache: Dict[str, Any])</span></p></div><p>One-step forward hypothesis.</p><ul><li><strong>Parameters:</strong><ul><li><strong>hyp</strong> – Hypothesis.</li><li><strong>cache</strong> – Pairs of (dec_out, dec_state) for each label sequence. (key)</li></ul></li><li><strong>Returns:</strong> Decoder output sequence. (1, D_dec) dec_state: Decoder hidden states. [N x (1, U, D_dec)] lm_label: Label ID for LM. (1,)</li><li><strong>Return type:</strong> dec_out</li></ul><div class="custom-h4"><p>select_state<span class="small-bracket">(states: List[Tensor | None], idx: int)</span></p></div><p>Get specified ID state from decoder hidden states.</p><ul><li><strong>Parameters:</strong><ul><li><strong>states</strong> – Decoder hidden states. [N x (B, U, D_dec)]</li><li><strong>idx</strong> – State ID to extract.</li></ul></li><li><strong>Returns:</strong> Decoder hidden state for given ID. [N x (1, U, D_dec)]</li><li><strong>Return type:</strong> state_idx</li></ul><div class="custom-h4"><p>set_device<span class="small-bracket">(device: device)</span></p></div><p>Set GPU device to use.</p><ul><li><strong>Parameters:</strong><strong>device</strong> – Device ID.</li></ul><div class="custom-h4"><p>training <em>: bool</em></p></div>',25);function y(b,D){const s=n("RouteLink");return d(),r("div",null,[i(" _espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder "),u,_,e("p",null,[t("Bases: "),a(s,{to:"/guide/espnet/nets/TransducerDecoderInterface.html#espnet.nets.transducer_decoder_interface.TransducerDecoderInterface"},{default:c(()=>[g]),_:1}),t(", "),m]),h])}const v=o(p,[["render",y],["__file","CustomDecoder.html.vue"]]),x=JSON.parse(`{"path":"/guide/espnet/nets/CustomDecoder.html","title":"espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.71,"words":513},"filePathRelative":"guide/espnet/nets/CustomDecoder.md","excerpt":"<!-- _espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder -->\\n<h1>espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.pytorch_backend.transducer.custom_decoder.CustomDecoder<span class=\\"small-bracket\\">(odim: int, dec_arch: List, input_layer: str = 'embed', repeat_block: int = 0, joint_activation_type: str = 'tanh', positional_encoding_type: str = 'abs_pos', positionwise_layer_type: str = 'linear', positionwise_activation_type: str = 'relu', input_layer_dropout_rate: float = 0.0, blank_id: int = 0)</span></p></div>"}`);export{v as comp,x as data};
