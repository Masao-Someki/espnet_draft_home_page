import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as e,a as n,o}from"./app-KOUU_Wij.js";const i={},r=n('<h1 id="espnet2-svs-singing-tacotron-encoder-encoder" tabindex="-1"><a class="header-anchor" href="#espnet2-svs-singing-tacotron-encoder-encoder"><span>espnet2.svs.singing_tacotron.encoder.Encoder</span></a></h1><div class="custom-h3"><p><em>class</em> espnet2.svs.singing_tacotron.encoder.Encoder<span class="small-bracket">(idim, input_layer=&#39;embed&#39;, embed_dim=512, elayers=1, eunits=512, econv_layers=3, econv_chans=512, econv_filts=5, use_batch_norm=True, use_residual=False, dropout_rate=0.5, padding_idx=0)</span></p></div><p>Bases: <code>Module</code></p><p>Encoder module of Spectrogram prediction network.</p><p>This is a module of encoder of Spectrogram prediction network in Singing Tacotron, which described in</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>`Singing-Tacotron: Global Duration Control Attention and Dynamic</span></span>\n<span class="line"><span>Filter for End-to-end Singing Voice Synthesis`_</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>. This is the encoder which converts either a sequence of characters or acoustic features into the sequence of hidden states.</p>',7),a=n('<p>Filter for End-to-end Singing Voice Synthesis`: : <a href="https://arxiv.org/abs/2202.07907" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2202.07907</a></p><p>Initialize Singing Tacotron encoder module.</p><ul><li><strong>Parameters:</strong><ul><li><strong>idim</strong> (<em>int</em>) –</li><li><strong>input_layer</strong> (<em>str</em>) – Input layer type.</li><li><strong>embed_dim</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>elayers</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>eunits</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>econv_layers</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>econv_filts</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>econv_chans</strong> (<em>int</em> <em>,</em> <em>optional</em>) –</li><li><strong>use_batch_norm</strong> (<em>bool</em> <em>,</em> <em>optional</em>) –</li><li><strong>use_residual</strong> (<em>bool</em> <em>,</em> <em>optional</em>) –</li><li><strong>dropout_rate</strong> (<em>float</em> <em>,</em> <em>optional</em>) –</li></ul></li></ul><div class="custom-h4"><p>forward<span class="small-bracket">(xs, ilens=None)</span></p></div><p>Calculate forward propagation.</p><ul><li><strong>Parameters:</strong><ul><li><strong>xs</strong> (<em>Tensor</em>) – Batch of the padded sequence. Either character ids (B, Tmax) or acoustic feature (B, Tmax, idim * encoder_reduction_factor). Padded value should be 0.</li><li><strong>ilens</strong> (<em>LongTensor</em>) – Batch of lengths of each input batch (B,).</li></ul></li><li><strong>Returns:</strong> Batch of the sequences of encoder states(B, Tmax, eunits). LongTensor: Batch of lengths of each sequence (B,)</li><li><strong>Return type:</strong> Tensor</li></ul><div class="custom-h4"><p>inference<span class="small-bracket">(x, ilens)</span></p></div><p>Inference.</p><ul><li><strong>Parameters:</strong><strong>x</strong> (<em>Tensor</em>) – The sequeunce of character ids (T,) or acoustic feature (T, idim * encoder_reduction_factor).</li><li><strong>Returns:</strong> The sequences of encoder states(T, eunits).</li><li><strong>Return type:</strong> Tensor</li></ul><div class="custom-h4"><p>training <em>: bool</em></p></div>',10);function l(c,d){return o(),t("div",null,[e(" _espnet2.svs.singing_tacotron.encoder.Encoder "),r,e(" _`Singing-Tacotron: Global Duration Control Attention and Dynamic "),a])}const g=s(i,[["render",l],["__file","Encoder.html.vue"]]),u=JSON.parse(`{"path":"/guide/espnet2/svs/Encoder.html","title":"espnet2.svs.singing_tacotron.encoder.Encoder","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.99,"words":298},"filePathRelative":"guide/espnet2/svs/Encoder.md","excerpt":"<!-- _espnet2.svs.singing_tacotron.encoder.Encoder -->\\n<h1>espnet2.svs.singing_tacotron.encoder.Encoder</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet2.svs.singing_tacotron.encoder.Encoder<span class=\\"small-bracket\\">(idim, input_layer='embed', embed_dim=512, elayers=1, eunits=512, econv_layers=3, econv_chans=512, econv_filts=5, use_batch_norm=True, use_residual=False, dropout_rate=0.5, padding_idx=0)</span></p></div>"}`);export{g as comp,u as data};
