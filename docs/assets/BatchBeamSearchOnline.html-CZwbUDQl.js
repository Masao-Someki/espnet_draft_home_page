import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,c,f as r,b as e,d as t,e as n,w as a,a as l,o as h}from"./app-KOUU_Wij.js";const _={},p=e("h1",{id:"espnet-nets-batch-beam-search-online-batchbeamsearchonline",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#espnet-nets-batch-beam-search-online-batchbeamsearchonline"},[e("span",null,"espnet.nets.batch_beam_search_online.BatchBeamSearchOnline")])],-1),d=e("div",{class:"custom-h3"},[e("p",null,[e("em",null,"class"),t(" espnet.nets.batch_beam_search_online.BatchBeamSearchOnline"),e("span",{class:"small-bracket"},"(*args, block_size=40, hop_size=16, look_ahead=16, disable_repetition_detection=False, encoded_feat_length_limit=0, decoder_text_length_limit=0, incremental_decode=False, time_sync=False, ctc=None, hold_n=0, transducer_conf=None, joint_network=None, **kwargs)")])],-1),m=e("code",null,"BatchBeamSearch",-1),u=l('<p>Online beam search implementation.</p><p>This simulates streaming decoding. It requires encoded features of entire utterance and extracts block by block from it as it shoud be done in streaming processing. This is based on Tsunoo et al, “STREAMING TRANSFORMER ASR WITH BLOCKWISE SYNCHRONOUS BEAM SEARCH” (<a href="https://arxiv.org/abs/2006.14941" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2006.14941</a>).</p><p>Initialize beam search.</p><div class="custom-h4"><p>assemble_hyps<span class="small-bracket">(ended_hyps)</span></p></div><p>Assemble the hypotheses.</p><div class="custom-h4"><p>extend<span class="small-bracket">(x: Tensor, hyps: Hypothesis)</span></p></div><p>Extend probabilities and states with more encoded chunks.</p>',7),b=e("strong",null,"Parameters:",-1),f=e("li",null,[e("strong",null,"x"),t(" ("),e("em",null,"torch.Tensor"),t(") – The extended encoder output feature")],-1),g=e("strong",null,"hyps",-1),y=e("em",null,"Hypothesis",-1),B=e("li",null,[e("strong",null,"Returns:"),t(" The extended hypothesis")],-1),x=e("strong",null,"Return type:",-1),k=e("div",{class:"custom-h4"},[e("p",null,[t("forward"),e("span",{class:"small-bracket"},"(x: Tensor, maxlenratio: float = 0.0, minlenratio: float = 0.0, is_final: bool = True)")])],-1),v=e("p",null,"Perform beam search.",-1),T=l("<li><strong>Parameters:</strong><ul><li><strong>x</strong> (<em>torch.Tensor</em>) – Encoded speech feature (T, D)</li><li><strong>maxlenratio</strong> (<em>float</em>) – Input length ratio to obtain max output length. If maxlenratio=0.0 (default), it uses a end-detect function to automatically find maximum hypothesis lengths</li><li><strong>minlenratio</strong> (<em>float</em>) – Input length ratio to obtain min output length.</li></ul></li><li><strong>Returns:</strong> N-best decoding results</li>",2),S=e("strong",null,"Return type:",-1),R=l('<div class="custom-h4"><p>process_one_block<span class="small-bracket">(h, is_final, maxlen, minlen, maxlenratio)</span></p></div><p>Recognize one block.</p><div class="custom-h4"><p>process_one_block_time_sync<span class="small-bracket">(h, is_final, maxlen, maxlenratio)</span></p></div><p>Recognize one block w/ time sync.</p><div class="custom-h4"><p>reset()</p></div><p>Reset parameters.</p><div class="custom-h4"><p>score_full<span class="small-bracket">(hyp: <a href="BatchHypothesis.md#espnet.nets.batch_beam_search.BatchHypothesis">BatchHypothesis</a></span>, x: Tensor, pre_x: Tensor | None = None)</p></div><p>Score new hypothesis by self.full_scorers.</p>',8),H=e("strong",null,"Parameters:",-1),N=e("strong",null,"hyp",-1),O=e("em",null,"Hypothesis",-1),w=e("li",null,[e("strong",null,"x"),t(" ("),e("em",null,"torch.Tensor"),t(") – Corresponding input feature")],-1),A=e("li",null,[e("strong",null,"pre_x"),t(" ("),e("em",null,"torch.Tensor"),t(") – Encoded speech feature for sequential attention (T, D)")],-1),E=e("li",null,[e("strong",null,"Returns:"),t(" Tuple of : score dict of hyp that has string keys of self.full_scorers and tensor score values of shape: (self.n_vocab,), and state dict that has string keys and state values of self.full_scorers")],-1),C=e("li",null,[e("strong",null,"Return type:"),t(" Tuple[Dict[str, torch.Tensor], Dict[str, Any]]")],-1),I=e("div",{class:"custom-h4"},[e("p",null,[t("training "),e("em",null,": bool")])],-1);function z(F,P){const s=i("RouteLink");return h(),c("div",null,[r(" _espnet.nets.batch_beam_search_online.BatchBeamSearchOnline "),p,d,e("p",null,[t("Bases: "),n(s,{to:"/guide/espnet/nets/BatchBeamSearch.html#espnet.nets.batch_beam_search.BatchBeamSearch"},{default:a(()=>[m]),_:1})]),u,e("ul",null,[e("li",null,[b,e("ul",null,[f,e("li",null,[g,t(" ("),n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:a(()=>[y]),_:1}),t(") – Current list of hypothesis")])])]),B,e("li",null,[x,n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:a(()=>[t("Hypothesis")]),_:1})])]),k,v,e("ul",null,[T,e("li",null,[S,t(" list["),n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:a(()=>[t("Hypothesis")]),_:1}),t("]")])]),R,e("ul",null,[e("li",null,[H,e("ul",null,[e("li",null,[N,t(" ("),n(s,{to:"/guide/espnet/nets/Hypothesis.html#espnet.nets.beam_search_partially_AR.Hypothesis"},{default:a(()=>[O]),_:1}),t(") – Hypothesis with prefix tokens to score")]),w,A])]),E,C]),I])}const L=o(_,[["render",z],["__file","BatchBeamSearchOnline.html.vue"]]),M=JSON.parse('{"path":"/guide/espnet/nets/BatchBeamSearchOnline.html","title":"espnet.nets.batch_beam_search_online.BatchBeamSearchOnline","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.38,"words":413},"filePathRelative":"guide/espnet/nets/BatchBeamSearchOnline.md","excerpt":"<!-- _espnet.nets.batch_beam_search_online.BatchBeamSearchOnline -->\\n<h1>espnet.nets.batch_beam_search_online.BatchBeamSearchOnline</h1>\\n<div class=\\"custom-h3\\"><p><em>class</em> espnet.nets.batch_beam_search_online.BatchBeamSearchOnline<span class=\\"small-bracket\\">(*args, block_size=40, hop_size=16, look_ahead=16, disable_repetition_detection=False, encoded_feat_length_limit=0, decoder_text_length_limit=0, incremental_decode=False, time_sync=False, ctc=None, hold_n=0, transducer_conf=None, joint_network=None, **kwargs)</span></p></div>"}');export{L as comp,M as data};
